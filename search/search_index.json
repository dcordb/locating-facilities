{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Locating Facilities Documentation Locating Facilities App An app that allows you to decide where to put a new point P given that it should be close from some set of points N and far from other set of points M . Installing requirements The requirements are: PuLP Matplotlib PySide2 pip install -r requirements.txt Running the app python run.py Report A report was made for this project, you can see it under /report/main.pdf .","title":"Home"},{"location":"#locating-facilities-documentation","text":"","title":"Locating Facilities Documentation"},{"location":"#locating-facilities-app","text":"An app that allows you to decide where to put a new point P given that it should be close from some set of points N and far from other set of points M .","title":"Locating Facilities App"},{"location":"#installing-requirements","text":"The requirements are: PuLP Matplotlib PySide2 pip install -r requirements.txt","title":"Installing requirements"},{"location":"#running-the-app","text":"python run.py","title":"Running the app"},{"location":"#report","text":"A report was made for this project, you can see it under /report/main.pdf .","title":"Report"},{"location":"api/controller/","text":"controller Controller loadFile ( self , file , models ) Source code in app/controller/controller.py def loadFile ( self , file : str , models ): with open ( file , 'rb' ) as f : try : obj = pickle . load ( f ) except pickle . PickleError : self . notifyError . emit ( ErrorReadingFile ) return near , far , xmin , xmax , ymin , ymax = obj self . _update ( near , far , xmin , xmax , ymin , ymax , models ) self . resetTextEditor . emit ( near , far , xmin , xmax , ymin , ymax ) loadRandomSample ( self , models ) Source code in app/controller/controller.py def loadRandomSample ( self , models ): n = random . randint ( 1 , 100 ) m = random . randint ( 1 , 100 ) round2 = lambda x : round ( x , 2 ) xmin = random . uniform ( - 100 , 0 ) ymin = random . uniform ( - 100 , 0 ) xmax = random . uniform ( 0 , 100 ) ymax = random . uniform ( 0 , 100 ) xmin = round2 ( xmin ) ymin = round2 ( ymin ) xmax = round2 ( xmax ) ymax = round2 ( ymax ) near = [] for _ in range ( n ): x = random . uniform ( xmin , xmax ) y = random . uniform ( ymin , ymax ) w = random . uniform ( 1 , 30 ) near . append ( PT ( round2 ( x ), round2 ( y ), round2 ( w ), kind = 'Near' )) far = [] for _ in range ( m ): x = random . uniform ( xmin , xmax ) y = random . uniform ( ymin , ymax ) w = random . uniform ( 1 , 30 ) far . append ( PT ( round2 ( x ), round2 ( y ), round2 ( w ), kind = 'Far' )) if not self . _update ( near , far , xmin , xmax , ymin , ymax , models ): return self . resetTextEditor . emit ( near , far , xmin , xmax , ymin , ymax ) loadText ( self , text , models , internal = False ) Source code in app/controller/controller.py def loadText ( self , text : str , models , internal = False ): lines = text . splitlines () parts = [] lstok = False for line in lines : if not line or line . isspace (): continue if '*' in line : lstok = False else : if not lstok : parts . append ([]) parts [ - 1 ] . append ( line ) lstok = True if len ( parts ) != PARAMS : self . notifyError . emit ( ErrorWholeFormat ) return bl , near = self . _readPoints ( parts [ 0 ], 'Near' ) if not bl : self . notifyError . emit ( ErrorPointFormat ) return bl , far = self . _readPoints ( parts [ 1 ], 'Far' ) if not bl : self . notifyError . emit ( ErrorPointFormat ) return if len ( parts [ 2 ]) != 1 : self . notifyError . emit ( ErrorXYFormat ) return line = parts [ 2 ][ 0 ] . split () if not all ( map ( self . _isfloat , line )): self . notifyError . emit ( ErrorXYFormat ) return xmin , xmax , ymin , ymax = map ( float , line ) if internal : return near , far , xmin , xmax , ymin , ymax self . _update ( near , far , xmin , xmax , ymin , ymax , models ) notifyError redrawCanvas resetLabel resetTextEditor saveFile ( self , file , text ) Source code in app/controller/controller.py def saveFile ( self , file , text ): obj = self . loadText ( text , models = None , internal = True ) with open ( file , 'wb' ) as f : pickle . dump ( obj , f )","title":"controller"},{"location":"api/controller/#app.controller","text":"","title":"app.controller"},{"location":"api/controller/#app.controller.controller","text":"","title":"controller"},{"location":"api/controller/#app.controller.controller.Controller","text":"","title":"Controller"},{"location":"api/controller/#app.controller.controller.Controller.loadFile","text":"Source code in app/controller/controller.py def loadFile ( self , file : str , models ): with open ( file , 'rb' ) as f : try : obj = pickle . load ( f ) except pickle . PickleError : self . notifyError . emit ( ErrorReadingFile ) return near , far , xmin , xmax , ymin , ymax = obj self . _update ( near , far , xmin , xmax , ymin , ymax , models ) self . resetTextEditor . emit ( near , far , xmin , xmax , ymin , ymax )","title":"loadFile()"},{"location":"api/controller/#app.controller.controller.Controller.loadRandomSample","text":"Source code in app/controller/controller.py def loadRandomSample ( self , models ): n = random . randint ( 1 , 100 ) m = random . randint ( 1 , 100 ) round2 = lambda x : round ( x , 2 ) xmin = random . uniform ( - 100 , 0 ) ymin = random . uniform ( - 100 , 0 ) xmax = random . uniform ( 0 , 100 ) ymax = random . uniform ( 0 , 100 ) xmin = round2 ( xmin ) ymin = round2 ( ymin ) xmax = round2 ( xmax ) ymax = round2 ( ymax ) near = [] for _ in range ( n ): x = random . uniform ( xmin , xmax ) y = random . uniform ( ymin , ymax ) w = random . uniform ( 1 , 30 ) near . append ( PT ( round2 ( x ), round2 ( y ), round2 ( w ), kind = 'Near' )) far = [] for _ in range ( m ): x = random . uniform ( xmin , xmax ) y = random . uniform ( ymin , ymax ) w = random . uniform ( 1 , 30 ) far . append ( PT ( round2 ( x ), round2 ( y ), round2 ( w ), kind = 'Far' )) if not self . _update ( near , far , xmin , xmax , ymin , ymax , models ): return self . resetTextEditor . emit ( near , far , xmin , xmax , ymin , ymax )","title":"loadRandomSample()"},{"location":"api/controller/#app.controller.controller.Controller.loadText","text":"Source code in app/controller/controller.py def loadText ( self , text : str , models , internal = False ): lines = text . splitlines () parts = [] lstok = False for line in lines : if not line or line . isspace (): continue if '*' in line : lstok = False else : if not lstok : parts . append ([]) parts [ - 1 ] . append ( line ) lstok = True if len ( parts ) != PARAMS : self . notifyError . emit ( ErrorWholeFormat ) return bl , near = self . _readPoints ( parts [ 0 ], 'Near' ) if not bl : self . notifyError . emit ( ErrorPointFormat ) return bl , far = self . _readPoints ( parts [ 1 ], 'Far' ) if not bl : self . notifyError . emit ( ErrorPointFormat ) return if len ( parts [ 2 ]) != 1 : self . notifyError . emit ( ErrorXYFormat ) return line = parts [ 2 ][ 0 ] . split () if not all ( map ( self . _isfloat , line )): self . notifyError . emit ( ErrorXYFormat ) return xmin , xmax , ymin , ymax = map ( float , line ) if internal : return near , far , xmin , xmax , ymin , ymax self . _update ( near , far , xmin , xmax , ymin , ymax , models )","title":"loadText()"},{"location":"api/controller/#app.controller.controller.Controller.notifyError","text":"","title":"notifyError"},{"location":"api/controller/#app.controller.controller.Controller.redrawCanvas","text":"","title":"redrawCanvas"},{"location":"api/controller/#app.controller.controller.Controller.resetLabel","text":"","title":"resetLabel"},{"location":"api/controller/#app.controller.controller.Controller.resetTextEditor","text":"","title":"resetTextEditor"},{"location":"api/controller/#app.controller.controller.Controller.saveFile","text":"Source code in app/controller/controller.py def saveFile ( self , file , text ): obj = self . loadText ( text , models = None , internal = True ) with open ( file , 'wb' ) as f : pickle . dump ( obj , f )","title":"saveFile()"},{"location":"api/gui/","text":"codeeditor CodeEditor __init__ ( self ) special Source code in app/gui/codeeditor.py def __init__ ( self ): QPlainTextEdit . __init__ ( self ) self . line_number_area = LineNumberArea ( self ) self . setPlaceholderText ( SidebarPlaceholderText ) self . setSizePolicy ( QSizePolicy . MinimumExpanding , QSizePolicy . MinimumExpanding ) self . blockCountChanged [ int ] . connect ( self . update_line_number_area_width ) self . updateRequest [ QRect , int ] . connect ( self . update_line_number_area ) self . cursorPositionChanged . connect ( self . highlight_current_line ) self . update_line_number_area_width ( 0 ) self . highlight_current_line () self . shortcut = QShortcut ( QKeySequence ( 'Ctrl+Shift+X' ), self ) highlight_current_line ( self ) Source code in app/gui/codeeditor.py @Slot () def highlight_current_line ( self ): extra_selections = [] if not self . isReadOnly (): selection = QTextEdit . ExtraSelection () line_color = QColor ( Qt . yellow ) . lighter ( 160 ) selection . format . setBackground ( line_color ) selection . format . setProperty ( QTextFormat . FullWidthSelection , True ) selection . cursor = self . textCursor () selection . cursor . clearSelection () extra_selections . append ( selection ) self . setExtraSelections ( extra_selections ) line_number_area_width ( self ) Source code in app/gui/codeeditor.py def line_number_area_width ( self ): digits = 1 max_num = max ( 1 , self . blockCount ()) while max_num >= 10 : max_num *= 0.1 digits += 1 space = 3 + self . fontMetrics () . width ( '9' ) * digits return space lineNumberAreaPaintEvent ( self , event ) Source code in app/gui/codeeditor.py def lineNumberAreaPaintEvent ( self , event ): painter = QPainter ( self . line_number_area ) painter . fillRect ( event . rect (), Qt . lightGray ) block = self . firstVisibleBlock () block_number = block . blockNumber () offset = self . contentOffset () top = self . blockBoundingGeometry ( block ) . translated ( offset ) . top () bottom = top + self . blockBoundingRect ( block ) . height () while block . isValid () and top <= event . rect () . bottom (): if block . isVisible () and bottom >= event . rect () . top (): number = str ( block_number + 1 ) painter . setPen ( Qt . black ) width = self . line_number_area . width () height = self . fontMetrics () . height () painter . drawText ( 0 , top , width , height , Qt . AlignRight , number ) block = block . next () top = bottom bottom = top + self . blockBoundingRect ( block ) . height () block_number += 1 resizeEvent ( self , e ) resizeEvent(self, e: PySide2.QtGui.QResizeEvent) Source code in app/gui/codeeditor.py def resizeEvent ( self , e ): super () . resizeEvent ( e ) cr = self . contentsRect () width = self . line_number_area_width () rect = QRect ( cr . left (), cr . top (), width , cr . height ()) self . line_number_area . setGeometry ( rect ) update_line_number_area ( self , rect , dy ) Source code in app/gui/codeeditor.py @Slot () def update_line_number_area ( self , rect , dy ): if dy : self . line_number_area . scroll ( 0 , dy ) else : width = self . line_number_area . width () self . line_number_area . update ( 0 , rect . y (), width , rect . height ()) if rect . contains ( self . viewport () . rect ()): self . update_line_number_area_width ( 0 ) update_line_number_area_width ( self , newBlockCount ) Source code in app/gui/codeeditor.py @Slot () def update_line_number_area_width ( self , newBlockCount ): self . setViewportMargins ( self . line_number_area_width (), 0 , 0 , 0 ) LineNumberArea __init__ ( self , editor ) special Source code in app/gui/codeeditor.py def __init__ ( self , editor ): QWidget . __init__ ( self , editor ) self . codeEditor = editor paintEvent ( self , event ) paintEvent(self, event: PySide2.QtGui.QPaintEvent) Source code in app/gui/codeeditor.py def paintEvent ( self , event ): self . codeEditor . lineNumberAreaPaintEvent ( event ) sizeHint ( self ) sizeHint(self) -> PySide2.QtCore.QSize Source code in app/gui/codeeditor.py def sizeHint ( self ): return QSize ( self . codeEditor . line_number_area_width (), 0 ) mainwindow CentralWidget Central widget formed by a canvas and an action widget __init__ ( self , canvas ) special Source code in app/gui/mainwindow.py def __init__ ( self , canvas ) -> None : qtw . QWidget . __init__ ( self ) self . canvas = canvas self . controller = Controller () self . setUI () self . setLoadDialog () self . setSaveDialog () self . setHelpDialog () self . setConnections () displayErrorMsg ( self , errorText ) Source code in app/gui/mainwindow.py def displayErrorMsg ( self , errorText ): qtw . QMessageBox . critical ( self , 'Error' , errorText ) onBtnHelp ( self ) Source code in app/gui/mainwindow.py @qtc . Slot () def onBtnHelp ( self ): self . helpDialog . open () onBtnLoad ( self ) Source code in app/gui/mainwindow.py @qtc . Slot () def onBtnLoad ( self ): self . loadDialog . open () onBtnSave ( self ) Source code in app/gui/mainwindow.py @qtc . Slot () def onBtnSave ( self ): filepath , _ = qtw . QFileDialog . getSaveFileName ( self ) if not filepath : return self . saveDialogExecuted . emit ( filepath , self . textEditor . toPlainText ()) pressedTextShortcut ( self ) Source code in app/gui/mainwindow.py @qtc . Slot () def pressedTextShortcut ( self ): ptext = self . textEditor . toPlainText () ctext = ptext or SidebarPlaceholderSample self . controller . loadText ( ctext , [ FastModel , FussyModel ]) if not ptext : self . textEditor . setPlainText ( ctext ) resetLabelInfo ( self , sols , costs ) Source code in app/gui/mainwindow.py def resetLabelInfo ( self , sols , costs ): text = [] for s , c in zip ( sols , costs ): text . append ( f 'point=( { s . x } , { s . y } ), cost= { c } using { s . kind } ' ) text = 'Found: ' + ', ' . join ( text ) + '.' self . labInfo . setText ( text ) resetTextEditorInfo ( self , near , far , xmin , xmax , ymin , ymax ) Source code in app/gui/mainwindow.py def resetTextEditorInfo ( self , near , far , xmin , xmax , ymin , ymax ): doFormat = lambda o : f ' { o . x } { o . y } { o . w } ' text = ' \\n ' . join ( map ( doFormat , near )) text += ' \\n * \\n ' text += ' \\n ' . join ( map ( doFormat , far )) text += ' \\n * \\n ' text += f ' { xmin } { xmax } { ymin } { ymax } ' self . textEditor . setPlainText ( text ) saveDialogExecuted setConnections ( self ) Source code in app/gui/mainwindow.py def setConnections ( self ): self . btnLoad . clicked . connect ( self . onBtnLoad ) self . btnSave . clicked . connect ( self . onBtnSave ) self . btnHelp . clicked . connect ( self . onBtnHelp ) self . textEditor . shortcut . activated . connect ( self . pressedTextShortcut ) self . controller . redrawCanvas . connect ( self . canvas . updateCanvas ) self . controller . resetLabel . connect ( self . resetLabelInfo ) self . controller . resetTextEditor . connect ( self . resetTextEditorInfo ) self . controller . notifyError . connect ( self . displayErrorMsg ) setHBoxActions ( self ) Source code in app/gui/mainwindow.py def setHBoxActions ( self ): self . hboxActions = qtw . QHBoxLayout () self . btnLoad = qtw . QPushButton ( '&Load' , sizePolicy = qtw . QSizePolicy ( qtw . QSizePolicy . Fixed , qtw . QSizePolicy . Fixed )) self . btnSave = qtw . QPushButton ( '&Save' , sizePolicy = qtw . QSizePolicy ( qtw . QSizePolicy . Fixed , qtw . QSizePolicy . Fixed )) self . labInfo = qtw . QLabel () self . btnHelp = qtw . QPushButton ( '&Help' , sizePolicy = qtw . QSizePolicy ( qtw . QSizePolicy . Fixed , qtw . QSizePolicy . Fixed )) self . separator = qtw . QFrame () self . separator . setFrameStyle ( qtw . QFrame . VLine | qtw . QFrame . Raised ) self . hboxActions . addWidget ( self . btnLoad ) self . hboxActions . addWidget ( self . btnSave ) self . hboxActions . addWidget ( self . separator ) self . hboxActions . addWidget ( self . labInfo ) self . hboxActions . addStretch () self . hboxActions . addWidget ( self . btnHelp ) setHelpDialog ( self ) Source code in app/gui/mainwindow.py def setHelpDialog ( self ): self . helpDialog = HelpDialog ( self ) setLoadDialog ( self ) Source code in app/gui/mainwindow.py def setLoadDialog ( self ): self . loadDialog = LoadDialog ( self ) self . loadDialog . choosedLoadFile . connect ( self . controller . loadFile ) self . loadDialog . choosedLoadRandom . connect ( self . controller . loadRandomSample ) self . loadDialog . choosedLoadSidebar . connect ( self . controller . loadText ) setSaveDialog ( self ) Source code in app/gui/mainwindow.py def setSaveDialog ( self ): self . saveDialogExecuted . connect ( self . controller . saveFile ) setUI ( self ) Source code in app/gui/mainwindow.py def setUI ( self ): self . setLayout ( qtw . QVBoxLayout ()) self . hboxCanvas = qtw . QHBoxLayout () self . hboxCanvas . addWidget ( self . canvas , stretch = 2 ) self . textEditor = CodeEditor () self . textEditor . setFocusPolicy ( qtc . Qt . StrongFocus ) self . textEditor . setFocus () self . hboxCanvas . addWidget ( self . textEditor , stretch = 1 ) self . layout () . addLayout ( self . hboxCanvas ) self . setHBoxActions () self . layout () . addLayout ( self . hboxActions ) HelpDialog __init__ ( self , parent = None ) special Source code in app/gui/mainwindow.py def __init__ ( self , parent = None ) -> None : qtw . QDialog . __init__ ( self , parent ) self . setUI () setUI ( self ) Source code in app/gui/mainwindow.py def setUI ( self ): self . setWindowTitle ( 'Help' ) self . setLayout ( qtw . QHBoxLayout ()) self . label = qtw . QLabel ( HELP_TEXT ) self . label . setTextFormat ( qtc . Qt . TextFormat . MarkdownText ) self . layout () . addWidget ( self . label ) self . layout () . setSizeConstraint ( qtw . QLayout . SetFixedSize ) LoadDialog Implements the load dialog __init__ ( self , parent = None ) special Source code in app/gui/mainwindow.py def __init__ ( self , parent = None ) -> None : qtw . QDialog . __init__ ( self , parent ) self . setUI () self . setConnections () choosedLoadFile choosedLoadRandom choosedLoadSidebar onAccepted ( self ) Source code in app/gui/mainwindow.py @qtc . Slot () def onAccepted ( self ): action = self . comboAction . currentData () models = self . comboModels . currentData () if action is Load . fromFile : filePath , _ = qtw . QFileDialog . getOpenFileName ( self . parent ()) if not filePath : return self . choosedLoadFile . emit ( filePath , models ) elif action is Load . fromSample : self . choosedLoadRandom . emit ( models ) else : text = self . parent () . textEditor . toPlainText () self . choosedLoadSidebar . emit ( text , models ) setConnections ( self ) Source code in app/gui/mainwindow.py def setConnections ( self ): self . btnBox . accepted . connect ( self . accept ) self . btnBox . rejected . connect ( self . reject ) self . accepted . connect ( self . onAccepted ) setUI ( self ) Source code in app/gui/mainwindow.py def setUI ( self ): self . setWindowTitle ( 'Load from' ) self . setWindowModality ( qtc . Qt . WindowModality . ApplicationModal ) self . comboAction = qtw . QComboBox () self . comboAction . addItem ( 'Load from file' , Load . fromFile ) self . comboAction . addItem ( 'Load random sample' , Load . fromSample ) self . comboAction . addItem ( 'Load from sidebar text field' , Load . fromSidebar ) self . comboModels = qtw . QComboBox () self . comboModels . addItem ( FastModel . __repr__ , [ FastModel ]) self . comboModels . addItem ( FussyModel . __repr__ , [ FussyModel ]) self . comboModels . addItem ( f ' { FastModel . __repr__ } , { FussyModel . __repr__ } ' , [ FastModel , FussyModel ]) self . form = qtw . QFormLayout () self . form . addRow ( 'Action' , self . comboAction ) self . form . addRow ( 'Model' , self . comboModels ) self . btnBox = qtw . QDialogButtonBox ( qtw . QDialogButtonBox . Ok | qtw . QDialogButtonBox . Cancel ) self . form . addRow ( self . btnBox ) self . form . setSizeConstraint ( qtw . QLayout . SetFixedSize ) self . setLayout ( self . form ) MainWindow Main Window __init__ ( self ) special Source code in app/gui/mainwindow.py def __init__ ( self ) -> None : qtw . QMainWindow . __init__ ( self ) self . loadCSS () self . setUI () loadCSS ( self ) Source code in app/gui/mainwindow.py def loadCSS ( self ): f = qtc . QFile ( ':/style.css' ) f . open ( qtc . QFile . ReadOnly | qtc . QFile . Text ) ts = qtc . QTextStream ( f ) css = ts . readAll () self . setStyleSheet ( css ) f . close () setUI ( self ) Source code in app/gui/mainwindow.py def setUI ( self ): self . setWindowTitle ( 'Locating Facilities' ) self . canvas = FacilitiesCanvas ( Figure ()) self . canvas . updateCanvas () self . toolbar = NavigationToolbar ( self . canvas , self ) self . addToolBar ( self . toolbar ) self . setCentralWidget ( CentralWidget ( self . canvas )) mpl FacilitiesCanvas Represents a canvas to plot facilities into. __init__ ( self , fig ) special Source code in app/gui/mpl.py def __init__ ( self , fig : Figure ) -> None : self . fig = fig FigureCanvas . __init__ ( self , self . fig ) self . setSizePolicy ( qtw . QSizePolicy . MinimumExpanding , qtw . QSizePolicy . MinimumExpanding ) self . pcs = [] self . from_who = [] self . mpl_connect ( 'motion_notify_event' , self . mplMouseMove ) mplMouseMove ( self , event ) Source code in app/gui/mpl.py def mplMouseMove ( self , event ): for pathc , who in zip ( self . pcs , self . from_who ): ocurred , ids = pathc . contains ( event ) if ocurred : globalPos = event . guiEvent . globalPos () idx = ids [ 'ind' ][ 0 ] qtw . QToolTip . showText ( globalPos , f 'Point from { who [ idx ] . kind } , index = { idx } , w = { who [ idx ] . w } ' ) break else : qtw . QToolTip . hideText () updateCanvas ( self , near = [], far = [], sols = []) Source code in app/gui/mpl.py def updateCanvas ( self , near : List [ PT ] = [], far : List [ PT ] = [], sols : List [ PT ] = []) -> None : xnear = [ x for x , _ , _ , _ in near ] ynear = [ y for _ , y , _ , _ in near ] xfar = [ x for x , _ , _ , _ in far ] yfar = [ y for _ , y , _ , _ in far ] ax = self . fig . gca () ax . clear () ax . grid () if not near and not far and not sols : return self . pcs = [] self . pcs . append ( ax . scatter ( xnear , ynear , label = 'Near' )) self . pcs . append ( ax . scatter ( xfar , yfar , label = 'Far' )) self . pcs . extend ([ ax . scatter ( x , y , label = f 'Optimum { kind } ' ) for x , y , _ , kind in sols ]) self . from_who = [ near , far ] self . from_who . extend ([ [ x ] for x in sols ]) ax . legend () ax . grid ( True ) xsols = [ x for x , _ , _ , _ in sols ] ysols = [ y for _ , y , _ , _ in sols ] xs = xnear + xfar + xsols ys = ynear + yfar + ysols self . fig . canvas . draw_idle ()","title":"gui"},{"location":"api/gui/#app.gui","text":"","title":"app.gui"},{"location":"api/gui/#app.gui.codeeditor","text":"","title":"codeeditor"},{"location":"api/gui/#app.gui.codeeditor.CodeEditor","text":"","title":"CodeEditor"},{"location":"api/gui/#app.gui.codeeditor.CodeEditor.__init__","text":"Source code in app/gui/codeeditor.py def __init__ ( self ): QPlainTextEdit . __init__ ( self ) self . line_number_area = LineNumberArea ( self ) self . setPlaceholderText ( SidebarPlaceholderText ) self . setSizePolicy ( QSizePolicy . MinimumExpanding , QSizePolicy . MinimumExpanding ) self . blockCountChanged [ int ] . connect ( self . update_line_number_area_width ) self . updateRequest [ QRect , int ] . connect ( self . update_line_number_area ) self . cursorPositionChanged . connect ( self . highlight_current_line ) self . update_line_number_area_width ( 0 ) self . highlight_current_line () self . shortcut = QShortcut ( QKeySequence ( 'Ctrl+Shift+X' ), self )","title":"__init__()"},{"location":"api/gui/#app.gui.codeeditor.CodeEditor.highlight_current_line","text":"Source code in app/gui/codeeditor.py @Slot () def highlight_current_line ( self ): extra_selections = [] if not self . isReadOnly (): selection = QTextEdit . ExtraSelection () line_color = QColor ( Qt . yellow ) . lighter ( 160 ) selection . format . setBackground ( line_color ) selection . format . setProperty ( QTextFormat . FullWidthSelection , True ) selection . cursor = self . textCursor () selection . cursor . clearSelection () extra_selections . append ( selection ) self . setExtraSelections ( extra_selections )","title":"highlight_current_line()"},{"location":"api/gui/#app.gui.codeeditor.CodeEditor.line_number_area_width","text":"Source code in app/gui/codeeditor.py def line_number_area_width ( self ): digits = 1 max_num = max ( 1 , self . blockCount ()) while max_num >= 10 : max_num *= 0.1 digits += 1 space = 3 + self . fontMetrics () . width ( '9' ) * digits return space","title":"line_number_area_width()"},{"location":"api/gui/#app.gui.codeeditor.CodeEditor.lineNumberAreaPaintEvent","text":"Source code in app/gui/codeeditor.py def lineNumberAreaPaintEvent ( self , event ): painter = QPainter ( self . line_number_area ) painter . fillRect ( event . rect (), Qt . lightGray ) block = self . firstVisibleBlock () block_number = block . blockNumber () offset = self . contentOffset () top = self . blockBoundingGeometry ( block ) . translated ( offset ) . top () bottom = top + self . blockBoundingRect ( block ) . height () while block . isValid () and top <= event . rect () . bottom (): if block . isVisible () and bottom >= event . rect () . top (): number = str ( block_number + 1 ) painter . setPen ( Qt . black ) width = self . line_number_area . width () height = self . fontMetrics () . height () painter . drawText ( 0 , top , width , height , Qt . AlignRight , number ) block = block . next () top = bottom bottom = top + self . blockBoundingRect ( block ) . height () block_number += 1","title":"lineNumberAreaPaintEvent()"},{"location":"api/gui/#app.gui.codeeditor.CodeEditor.resizeEvent","text":"resizeEvent(self, e: PySide2.QtGui.QResizeEvent) Source code in app/gui/codeeditor.py def resizeEvent ( self , e ): super () . resizeEvent ( e ) cr = self . contentsRect () width = self . line_number_area_width () rect = QRect ( cr . left (), cr . top (), width , cr . height ()) self . line_number_area . setGeometry ( rect )","title":"resizeEvent()"},{"location":"api/gui/#app.gui.codeeditor.CodeEditor.update_line_number_area","text":"Source code in app/gui/codeeditor.py @Slot () def update_line_number_area ( self , rect , dy ): if dy : self . line_number_area . scroll ( 0 , dy ) else : width = self . line_number_area . width () self . line_number_area . update ( 0 , rect . y (), width , rect . height ()) if rect . contains ( self . viewport () . rect ()): self . update_line_number_area_width ( 0 )","title":"update_line_number_area()"},{"location":"api/gui/#app.gui.codeeditor.CodeEditor.update_line_number_area_width","text":"Source code in app/gui/codeeditor.py @Slot () def update_line_number_area_width ( self , newBlockCount ): self . setViewportMargins ( self . line_number_area_width (), 0 , 0 , 0 )","title":"update_line_number_area_width()"},{"location":"api/gui/#app.gui.codeeditor.LineNumberArea","text":"","title":"LineNumberArea"},{"location":"api/gui/#app.gui.codeeditor.LineNumberArea.__init__","text":"Source code in app/gui/codeeditor.py def __init__ ( self , editor ): QWidget . __init__ ( self , editor ) self . codeEditor = editor","title":"__init__()"},{"location":"api/gui/#app.gui.codeeditor.LineNumberArea.paintEvent","text":"paintEvent(self, event: PySide2.QtGui.QPaintEvent) Source code in app/gui/codeeditor.py def paintEvent ( self , event ): self . codeEditor . lineNumberAreaPaintEvent ( event )","title":"paintEvent()"},{"location":"api/gui/#app.gui.codeeditor.LineNumberArea.sizeHint","text":"sizeHint(self) -> PySide2.QtCore.QSize Source code in app/gui/codeeditor.py def sizeHint ( self ): return QSize ( self . codeEditor . line_number_area_width (), 0 )","title":"sizeHint()"},{"location":"api/gui/#app.gui.mainwindow","text":"","title":"mainwindow"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget","text":"Central widget formed by a canvas and an action widget","title":"CentralWidget"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.__init__","text":"Source code in app/gui/mainwindow.py def __init__ ( self , canvas ) -> None : qtw . QWidget . __init__ ( self ) self . canvas = canvas self . controller = Controller () self . setUI () self . setLoadDialog () self . setSaveDialog () self . setHelpDialog () self . setConnections ()","title":"__init__()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.displayErrorMsg","text":"Source code in app/gui/mainwindow.py def displayErrorMsg ( self , errorText ): qtw . QMessageBox . critical ( self , 'Error' , errorText )","title":"displayErrorMsg()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.onBtnHelp","text":"Source code in app/gui/mainwindow.py @qtc . Slot () def onBtnHelp ( self ): self . helpDialog . open ()","title":"onBtnHelp()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.onBtnLoad","text":"Source code in app/gui/mainwindow.py @qtc . Slot () def onBtnLoad ( self ): self . loadDialog . open ()","title":"onBtnLoad()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.onBtnSave","text":"Source code in app/gui/mainwindow.py @qtc . Slot () def onBtnSave ( self ): filepath , _ = qtw . QFileDialog . getSaveFileName ( self ) if not filepath : return self . saveDialogExecuted . emit ( filepath , self . textEditor . toPlainText ())","title":"onBtnSave()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.pressedTextShortcut","text":"Source code in app/gui/mainwindow.py @qtc . Slot () def pressedTextShortcut ( self ): ptext = self . textEditor . toPlainText () ctext = ptext or SidebarPlaceholderSample self . controller . loadText ( ctext , [ FastModel , FussyModel ]) if not ptext : self . textEditor . setPlainText ( ctext )","title":"pressedTextShortcut()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.resetLabelInfo","text":"Source code in app/gui/mainwindow.py def resetLabelInfo ( self , sols , costs ): text = [] for s , c in zip ( sols , costs ): text . append ( f 'point=( { s . x } , { s . y } ), cost= { c } using { s . kind } ' ) text = 'Found: ' + ', ' . join ( text ) + '.' self . labInfo . setText ( text )","title":"resetLabelInfo()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.resetTextEditorInfo","text":"Source code in app/gui/mainwindow.py def resetTextEditorInfo ( self , near , far , xmin , xmax , ymin , ymax ): doFormat = lambda o : f ' { o . x } { o . y } { o . w } ' text = ' \\n ' . join ( map ( doFormat , near )) text += ' \\n * \\n ' text += ' \\n ' . join ( map ( doFormat , far )) text += ' \\n * \\n ' text += f ' { xmin } { xmax } { ymin } { ymax } ' self . textEditor . setPlainText ( text )","title":"resetTextEditorInfo()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.saveDialogExecuted","text":"","title":"saveDialogExecuted"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.setConnections","text":"Source code in app/gui/mainwindow.py def setConnections ( self ): self . btnLoad . clicked . connect ( self . onBtnLoad ) self . btnSave . clicked . connect ( self . onBtnSave ) self . btnHelp . clicked . connect ( self . onBtnHelp ) self . textEditor . shortcut . activated . connect ( self . pressedTextShortcut ) self . controller . redrawCanvas . connect ( self . canvas . updateCanvas ) self . controller . resetLabel . connect ( self . resetLabelInfo ) self . controller . resetTextEditor . connect ( self . resetTextEditorInfo ) self . controller . notifyError . connect ( self . displayErrorMsg )","title":"setConnections()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.setHBoxActions","text":"Source code in app/gui/mainwindow.py def setHBoxActions ( self ): self . hboxActions = qtw . QHBoxLayout () self . btnLoad = qtw . QPushButton ( '&Load' , sizePolicy = qtw . QSizePolicy ( qtw . QSizePolicy . Fixed , qtw . QSizePolicy . Fixed )) self . btnSave = qtw . QPushButton ( '&Save' , sizePolicy = qtw . QSizePolicy ( qtw . QSizePolicy . Fixed , qtw . QSizePolicy . Fixed )) self . labInfo = qtw . QLabel () self . btnHelp = qtw . QPushButton ( '&Help' , sizePolicy = qtw . QSizePolicy ( qtw . QSizePolicy . Fixed , qtw . QSizePolicy . Fixed )) self . separator = qtw . QFrame () self . separator . setFrameStyle ( qtw . QFrame . VLine | qtw . QFrame . Raised ) self . hboxActions . addWidget ( self . btnLoad ) self . hboxActions . addWidget ( self . btnSave ) self . hboxActions . addWidget ( self . separator ) self . hboxActions . addWidget ( self . labInfo ) self . hboxActions . addStretch () self . hboxActions . addWidget ( self . btnHelp )","title":"setHBoxActions()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.setHelpDialog","text":"Source code in app/gui/mainwindow.py def setHelpDialog ( self ): self . helpDialog = HelpDialog ( self )","title":"setHelpDialog()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.setLoadDialog","text":"Source code in app/gui/mainwindow.py def setLoadDialog ( self ): self . loadDialog = LoadDialog ( self ) self . loadDialog . choosedLoadFile . connect ( self . controller . loadFile ) self . loadDialog . choosedLoadRandom . connect ( self . controller . loadRandomSample ) self . loadDialog . choosedLoadSidebar . connect ( self . controller . loadText )","title":"setLoadDialog()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.setSaveDialog","text":"Source code in app/gui/mainwindow.py def setSaveDialog ( self ): self . saveDialogExecuted . connect ( self . controller . saveFile )","title":"setSaveDialog()"},{"location":"api/gui/#app.gui.mainwindow.CentralWidget.setUI","text":"Source code in app/gui/mainwindow.py def setUI ( self ): self . setLayout ( qtw . QVBoxLayout ()) self . hboxCanvas = qtw . QHBoxLayout () self . hboxCanvas . addWidget ( self . canvas , stretch = 2 ) self . textEditor = CodeEditor () self . textEditor . setFocusPolicy ( qtc . Qt . StrongFocus ) self . textEditor . setFocus () self . hboxCanvas . addWidget ( self . textEditor , stretch = 1 ) self . layout () . addLayout ( self . hboxCanvas ) self . setHBoxActions () self . layout () . addLayout ( self . hboxActions )","title":"setUI()"},{"location":"api/gui/#app.gui.mainwindow.HelpDialog","text":"","title":"HelpDialog"},{"location":"api/gui/#app.gui.mainwindow.HelpDialog.__init__","text":"Source code in app/gui/mainwindow.py def __init__ ( self , parent = None ) -> None : qtw . QDialog . __init__ ( self , parent ) self . setUI ()","title":"__init__()"},{"location":"api/gui/#app.gui.mainwindow.HelpDialog.setUI","text":"Source code in app/gui/mainwindow.py def setUI ( self ): self . setWindowTitle ( 'Help' ) self . setLayout ( qtw . QHBoxLayout ()) self . label = qtw . QLabel ( HELP_TEXT ) self . label . setTextFormat ( qtc . Qt . TextFormat . MarkdownText ) self . layout () . addWidget ( self . label ) self . layout () . setSizeConstraint ( qtw . QLayout . SetFixedSize )","title":"setUI()"},{"location":"api/gui/#app.gui.mainwindow.LoadDialog","text":"Implements the load dialog","title":"LoadDialog"},{"location":"api/gui/#app.gui.mainwindow.LoadDialog.__init__","text":"Source code in app/gui/mainwindow.py def __init__ ( self , parent = None ) -> None : qtw . QDialog . __init__ ( self , parent ) self . setUI () self . setConnections ()","title":"__init__()"},{"location":"api/gui/#app.gui.mainwindow.LoadDialog.choosedLoadFile","text":"","title":"choosedLoadFile"},{"location":"api/gui/#app.gui.mainwindow.LoadDialog.choosedLoadRandom","text":"","title":"choosedLoadRandom"},{"location":"api/gui/#app.gui.mainwindow.LoadDialog.choosedLoadSidebar","text":"","title":"choosedLoadSidebar"},{"location":"api/gui/#app.gui.mainwindow.LoadDialog.onAccepted","text":"Source code in app/gui/mainwindow.py @qtc . Slot () def onAccepted ( self ): action = self . comboAction . currentData () models = self . comboModels . currentData () if action is Load . fromFile : filePath , _ = qtw . QFileDialog . getOpenFileName ( self . parent ()) if not filePath : return self . choosedLoadFile . emit ( filePath , models ) elif action is Load . fromSample : self . choosedLoadRandom . emit ( models ) else : text = self . parent () . textEditor . toPlainText () self . choosedLoadSidebar . emit ( text , models )","title":"onAccepted()"},{"location":"api/gui/#app.gui.mainwindow.LoadDialog.setConnections","text":"Source code in app/gui/mainwindow.py def setConnections ( self ): self . btnBox . accepted . connect ( self . accept ) self . btnBox . rejected . connect ( self . reject ) self . accepted . connect ( self . onAccepted )","title":"setConnections()"},{"location":"api/gui/#app.gui.mainwindow.LoadDialog.setUI","text":"Source code in app/gui/mainwindow.py def setUI ( self ): self . setWindowTitle ( 'Load from' ) self . setWindowModality ( qtc . Qt . WindowModality . ApplicationModal ) self . comboAction = qtw . QComboBox () self . comboAction . addItem ( 'Load from file' , Load . fromFile ) self . comboAction . addItem ( 'Load random sample' , Load . fromSample ) self . comboAction . addItem ( 'Load from sidebar text field' , Load . fromSidebar ) self . comboModels = qtw . QComboBox () self . comboModels . addItem ( FastModel . __repr__ , [ FastModel ]) self . comboModels . addItem ( FussyModel . __repr__ , [ FussyModel ]) self . comboModels . addItem ( f ' { FastModel . __repr__ } , { FussyModel . __repr__ } ' , [ FastModel , FussyModel ]) self . form = qtw . QFormLayout () self . form . addRow ( 'Action' , self . comboAction ) self . form . addRow ( 'Model' , self . comboModels ) self . btnBox = qtw . QDialogButtonBox ( qtw . QDialogButtonBox . Ok | qtw . QDialogButtonBox . Cancel ) self . form . addRow ( self . btnBox ) self . form . setSizeConstraint ( qtw . QLayout . SetFixedSize ) self . setLayout ( self . form )","title":"setUI()"},{"location":"api/gui/#app.gui.mainwindow.MainWindow","text":"Main Window","title":"MainWindow"},{"location":"api/gui/#app.gui.mainwindow.MainWindow.__init__","text":"Source code in app/gui/mainwindow.py def __init__ ( self ) -> None : qtw . QMainWindow . __init__ ( self ) self . loadCSS () self . setUI ()","title":"__init__()"},{"location":"api/gui/#app.gui.mainwindow.MainWindow.loadCSS","text":"Source code in app/gui/mainwindow.py def loadCSS ( self ): f = qtc . QFile ( ':/style.css' ) f . open ( qtc . QFile . ReadOnly | qtc . QFile . Text ) ts = qtc . QTextStream ( f ) css = ts . readAll () self . setStyleSheet ( css ) f . close ()","title":"loadCSS()"},{"location":"api/gui/#app.gui.mainwindow.MainWindow.setUI","text":"Source code in app/gui/mainwindow.py def setUI ( self ): self . setWindowTitle ( 'Locating Facilities' ) self . canvas = FacilitiesCanvas ( Figure ()) self . canvas . updateCanvas () self . toolbar = NavigationToolbar ( self . canvas , self ) self . addToolBar ( self . toolbar ) self . setCentralWidget ( CentralWidget ( self . canvas ))","title":"setUI()"},{"location":"api/gui/#app.gui.mpl","text":"","title":"mpl"},{"location":"api/gui/#app.gui.mpl.FacilitiesCanvas","text":"Represents a canvas to plot facilities into.","title":"FacilitiesCanvas"},{"location":"api/gui/#app.gui.mpl.FacilitiesCanvas.__init__","text":"Source code in app/gui/mpl.py def __init__ ( self , fig : Figure ) -> None : self . fig = fig FigureCanvas . __init__ ( self , self . fig ) self . setSizePolicy ( qtw . QSizePolicy . MinimumExpanding , qtw . QSizePolicy . MinimumExpanding ) self . pcs = [] self . from_who = [] self . mpl_connect ( 'motion_notify_event' , self . mplMouseMove )","title":"__init__()"},{"location":"api/gui/#app.gui.mpl.FacilitiesCanvas.mplMouseMove","text":"Source code in app/gui/mpl.py def mplMouseMove ( self , event ): for pathc , who in zip ( self . pcs , self . from_who ): ocurred , ids = pathc . contains ( event ) if ocurred : globalPos = event . guiEvent . globalPos () idx = ids [ 'ind' ][ 0 ] qtw . QToolTip . showText ( globalPos , f 'Point from { who [ idx ] . kind } , index = { idx } , w = { who [ idx ] . w } ' ) break else : qtw . QToolTip . hideText ()","title":"mplMouseMove()"},{"location":"api/gui/#app.gui.mpl.FacilitiesCanvas.updateCanvas","text":"Source code in app/gui/mpl.py def updateCanvas ( self , near : List [ PT ] = [], far : List [ PT ] = [], sols : List [ PT ] = []) -> None : xnear = [ x for x , _ , _ , _ in near ] ynear = [ y for _ , y , _ , _ in near ] xfar = [ x for x , _ , _ , _ in far ] yfar = [ y for _ , y , _ , _ in far ] ax = self . fig . gca () ax . clear () ax . grid () if not near and not far and not sols : return self . pcs = [] self . pcs . append ( ax . scatter ( xnear , ynear , label = 'Near' )) self . pcs . append ( ax . scatter ( xfar , yfar , label = 'Far' )) self . pcs . extend ([ ax . scatter ( x , y , label = f 'Optimum { kind } ' ) for x , y , _ , kind in sols ]) self . from_who = [ near , far ] self . from_who . extend ([ [ x ] for x in sols ]) ax . legend () ax . grid ( True ) xsols = [ x for x , _ , _ , _ in sols ] ysols = [ y for _ , y , _ , _ in sols ] xs = xnear + xfar + xsols ys = ynear + yfar + ysols self . fig . canvas . draw_idle ()","title":"updateCanvas()"},{"location":"api/models/","text":"fastmodel arrcost ( p , arr ) Source code in app/models/fastmodel.py def arrcost ( p , arr ): cost = 0 for v in arr : cost += v . w * ( abs ( v . x - p . x ) + abs ( v . y - p . y )) return cost C C(c, w) eval ( p , near , far ) Source code in app/models/fastmodel.py def eval ( p : PT , near : List [ PT ], far : List [ PT ]): return arrcost ( p , near ) - arrcost ( p , far ) getcost ( x , vals , sumW , sumWM ) Source code in app/models/fastmodel.py def getcost ( x : float , vals : List [ float ], sumW : List [ float ], sumWM : List [ float ]) -> float : p = bisect_right ( vals , x ) # greater than x n = getsum ( sumWM , p , len ( sumWM ) - 1 ) m = - getsum ( sumW , p , len ( sumW ) - 1 ) # less than or equal to x n += - getsum ( sumWM , 0 , p - 1 ) m += getsum ( sumW , 0 , p - 1 ) return x * m + n getsum ( vals , l , r ) Source code in app/models/fastmodel.py def getsum ( vals : List [ float ], l , r ) -> float : if l > r : return 0. assert l >= 0 and r < len ( vals ) return vals [ r ] - ( vals [ l - 1 ] if l >= 1 else 0. ) optimize ( near , far , xmin , xmax , ymin , ymax ) FastModel optimize function Parameters: Name Type Description Default near List[app.utils.utils.PT] set of points we want to get close to. required far List[app.utils.utils.PT] set of points we want to get far from. required xmin float lower left x coordinate of the solution rectangle. required xmax float lower right x coordinate of the solution rectangle. required ymin float upper left x coordinate of the solution rectangle. required ymax float upper right x coordinate of the solution rectangle. required Returns: Type Description Tuple[app.utils.utils.PT, float] A tuple containing the point and the value of the objective function. Source code in app/models/fastmodel.py def optimize ( near : List [ PT ], far : List [ PT ], xmin : float , xmax : float , ymin : float , ymax : float ) -> Tuple [ PT , float ]: '''FastModel optimize function Args: near: set of points we want to get close to. far: set of points we want to get far from. xmin: lower left `x` coordinate of the solution rectangle. xmax: lower right `x` coordinate of the solution rectangle. ymin: upper left `x` coordinate of the solution rectangle. ymax: upper right `x` coordinate of the solution rectangle. Returns: A tuple containing the point and the value of the objective function. ''' # find optimal x xnear = [ C ( x , w ) for x , _ , w , _ in near ] xfar = [ C ( x , w ) for x , _ , w , _ in far ] xboundaries = [ C ( xmin ), C ( xmax ) ] x , cx = solvecoord ( xnear , xfar , xboundaries ) # find optimal y ynear = [ C ( y , w ) for _ , y , w , _ in near ] yfar = [ C ( y , w ) for _ , y , w , _ in far ] yboundaries = [ C ( ymin ), C ( ymax )] y , cy = solvecoord ( ynear , yfar , yboundaries ) return PT ( x , y , w = 0 , kind = 'FastModel' ), cx + cy precalc_sums ( coord ) Source code in app/models/fastmodel.py def precalc_sums ( coord : List [ C ]) -> Tuple [ List [ float ], List [ float ]]: n = len ( coord ) sumW = [ 0. ] * n sumWM = [ 0. ] * n for i , ( x , w ) in enumerate ( coord ): if i > 0 : sumW [ i ] = sumW [ i - 1 ] sumWM [ i ] = sumWM [ i - 1 ] sumW [ i ] += w sumWM [ i ] += x * w return sumW , sumWM solvecoord ( cnear , cfar , boundaries ) Source code in app/models/fastmodel.py def solvecoord ( cnear : List [ C ], cfar : List [ C ], boundaries : List [ C ]) -> Tuple [ float , float ]: cnear = sorted ( cnear , key = lambda x : x . c ) cfar = sorted ( cfar , key = lambda x : x . c ) sumw_near , sumwm_near = precalc_sums ( cnear ) sumw_far , sumwm_far = precalc_sums ( cfar ) near_vals = [ c . c for c in cnear ] far_vals = [ c . c for c in cfar ] opt = 1e18 ans = 0 for x , _ in cnear + cfar + boundaries : cost = getcost ( x , near_vals , sumw_near , sumwm_near ) cost -= getcost ( x , far_vals , sumw_far , sumwm_far ) if cost < opt : opt = cost ans = x return ans , opt fussymodel dot ( a , b ) Source code in app/models/fussymodel.py def dot ( a , b ): return sum ( x * y for x , y in zip ( a , b )) evalZ1 ( near , X , Y ) Source code in app/models/fussymodel.py def evalZ1 ( near : List [ PT ], X : float , Y : float ): return max ( w * ( abs ( x - X ) + abs ( y - Y )) for x , y , w , _ in near ) evalZ2 ( xca , yca , xcb , ycb , X , Y ) Source code in app/models/fussymodel.py def evalZ2 ( xca , yca , xcb , ycb , X , Y ): return abs ( xca - X ) + abs ( yca - Y ) + abs ( X - xcb ) + abs ( Y - ycb ) extractconstants ( arr ) Source code in app/models/fussymodel.py def extractconstants ( arr : List [ PT ]): xs = [ x for x , _ , _ , _ in arr ] ys = [ y for _ , y , _ , _ in arr ] ws = [ w for _ , _ , w , _ in arr ] return xs , ys , ws optimize ( near , far , xmin , xmax , ymin , ymax ) Source code in app/models/fussymodel.py def optimize ( near : List [ PT ], far : List [ PT ], xmin : float , xmax : float , ymin : float , ymax : float ): xs_near , ys_near , ws_near = extractconstants ( near ) xs_far , ys_far , ws_far = extractconstants ( far ) xca = dot ( xs_near , ws_near ) / len ( near ) yca = dot ( ys_near , ws_near ) / len ( near ) xcb = dot ( xs_far , ws_far ) / len ( far ) ycb = dot ( ys_far , ws_far ) / len ( far ) X1 , Y1 = solveZ1 ( xs_near , ys_near , ws_near , xmin , xmax , ymin , ymax ) X2 , Y2 = solveZ2 ( xca , yca , xcb , ycb , xmin , xmax , ymin , ymax ) U1 = max ( evalZ1 ( near , X1 , Y1 ), evalZ1 ( near , X2 , Y2 )) U2 = max ( evalZ2 ( xca , yca , xcb , ycb , X1 , Y1 ), evalZ2 ( xca , yca , xcb , ycb , X2 , Y2 )) L1 = evalZ1 ( near , X1 , Y1 ) L2 = evalZ2 ( xca , yca , xcb , ycb , X2 , Y2 ) prob = pulp . LpProblem ( 'FussyModel' , pulp . LpMaximize ) # for first model ps = [ pulp . LpVariable ( f 'p_ { i } ' ) for i in range ( len ( near )) ] qs = [ pulp . LpVariable ( f 'q_ { i } ' ) for i in range ( len ( near )) ] # for second model ts = [ pulp . LpVariable ( f 't_ { i } ' , 0 ) for i in range ( 4 ) ] lmb = pulp . LpVariable ( 'lambda' , 0 , 1 ) Z1 = pulp . LpVariable ( 'Z1' , 0 ) Z2 = pulp . LpVariable ( 'Z2' , 0 ) X = pulp . LpVariable ( 'X' , xmin , xmax ) Y = pulp . LpVariable ( 'Y' , ymin , ymax ) # objective function prob += lmb # restrictions prob += U1 * lmb - L1 * lmb <= U1 - Z1 prob += U2 * lmb - L2 * lmb <= U2 - Z2 # from Z1 model for p , q , x , y , w in zip ( ps , qs , xs_near , ys_near , ws_near ): prob += p >= x - X prob += p >= X - x prob += q >= y - Y prob += q >= Y - y prob += w * p + w * q <= Z1 # from Z2 model prob += Z2 == ts [ 0 ] + ts [ 1 ] + ts [ 2 ] + ts [ 3 ] prob += ts [ 0 ] >= X - xca prob += ts [ 0 ] >= xca - X prob += ts [ 1 ] >= Y - yca prob += ts [ 1 ] >= yca - Y prob += ts [ 2 ] >= X - xcb prob += ts [ 2 ] >= xcb - X prob += ts [ 3 ] >= Y - ycb prob += ts [ 3 ] >= ycb - Y prob . solve ( pulp . PULP_CBC_CMD ( msg = False )) assert pulp . LpStatus [ prob . status ] == 'Optimal' return PT ( X . varValue , Y . varValue , w = 0 , kind = 'FussyModel' ), Z1 . varValue + Z2 . varValue solveZ1 ( xs , ys , ws , xmin , xmax , ymin , ymax ) Source code in app/models/fussymodel.py def solveZ1 ( xs : List [ float ], ys : List [ float ], ws : List [ float ], xmin : float , xmax : float , ymin : float , ymax : float ): n = len ( xs ) prob = pulp . LpProblem ( 'Z1_objective' ) Z1 = pulp . LpVariable ( 'Z1' , 0 ) X = pulp . LpVariable ( 'X' , xmin , xmax ) Y = pulp . LpVariable ( 'Y' , ymin , ymax ) ps = [ pulp . LpVariable ( f 'p_ { i } ' ) for i in range ( n ) ] qs = [ pulp . LpVariable ( f 'q_ { i } ' ) for i in range ( n ) ] prob += Z1 for p , q , x , y , w in zip ( ps , qs , xs , ys , ws ): prob += p >= x - X prob += p >= X - x prob += q >= y - Y prob += q >= Y - y prob += w * p + w * q <= Z1 prob . solve ( pulp . PULP_CBC_CMD ( msg = False )) assert pulp . LpStatus [ prob . status ] == 'Optimal' return X . varValue , Y . varValue solveZ2 ( xca , yca , xcb , ycb , xmin , xmax , ymin , ymax ) Source code in app/models/fussymodel.py def solveZ2 ( xca : float , yca : float , xcb : float , ycb : float , xmin : float , xmax : float , ymin : float , ymax : float ): prob = pulp . LpProblem ( 'Z2_objective' ) Z2 = pulp . LpVariable ( 'Z2' , 0 ) X = pulp . LpVariable ( 'X' , xmin , xmax ) Y = pulp . LpVariable ( 'Y' , ymin , ymax ) ts = [ pulp . LpVariable ( f 't_ { i } ' , 0 ) for i in range ( 4 ) ] prob += Z2 prob += Z2 == ts [ 0 ] + ts [ 1 ] + ts [ 2 ] + ts [ 3 ] prob += ts [ 0 ] >= X - xca prob += ts [ 0 ] >= xca - X prob += ts [ 1 ] >= Y - yca prob += ts [ 1 ] >= yca - Y prob += ts [ 2 ] >= X - xcb prob += ts [ 2 ] >= xcb - X prob += ts [ 3 ] >= Y - ycb prob += ts [ 3 ] >= ycb - Y prob . solve ( pulp . PULP_CBC_CMD ( msg = False )) assert pulp . LpStatus [ prob . status ] == 'Optimal' return X . varValue , Y . varValue","title":"models"},{"location":"api/models/#app.models","text":"","title":"app.models"},{"location":"api/models/#app.models.fastmodel","text":"","title":"fastmodel"},{"location":"api/models/#app.models.fastmodel.arrcost","text":"Source code in app/models/fastmodel.py def arrcost ( p , arr ): cost = 0 for v in arr : cost += v . w * ( abs ( v . x - p . x ) + abs ( v . y - p . y )) return cost","title":"arrcost()"},{"location":"api/models/#app.models.fastmodel.C","text":"C(c, w)","title":"C"},{"location":"api/models/#app.models.fastmodel.eval","text":"Source code in app/models/fastmodel.py def eval ( p : PT , near : List [ PT ], far : List [ PT ]): return arrcost ( p , near ) - arrcost ( p , far )","title":"eval()"},{"location":"api/models/#app.models.fastmodel.getcost","text":"Source code in app/models/fastmodel.py def getcost ( x : float , vals : List [ float ], sumW : List [ float ], sumWM : List [ float ]) -> float : p = bisect_right ( vals , x ) # greater than x n = getsum ( sumWM , p , len ( sumWM ) - 1 ) m = - getsum ( sumW , p , len ( sumW ) - 1 ) # less than or equal to x n += - getsum ( sumWM , 0 , p - 1 ) m += getsum ( sumW , 0 , p - 1 ) return x * m + n","title":"getcost()"},{"location":"api/models/#app.models.fastmodel.getsum","text":"Source code in app/models/fastmodel.py def getsum ( vals : List [ float ], l , r ) -> float : if l > r : return 0. assert l >= 0 and r < len ( vals ) return vals [ r ] - ( vals [ l - 1 ] if l >= 1 else 0. )","title":"getsum()"},{"location":"api/models/#app.models.fastmodel.optimize","text":"FastModel optimize function Parameters: Name Type Description Default near List[app.utils.utils.PT] set of points we want to get close to. required far List[app.utils.utils.PT] set of points we want to get far from. required xmin float lower left x coordinate of the solution rectangle. required xmax float lower right x coordinate of the solution rectangle. required ymin float upper left x coordinate of the solution rectangle. required ymax float upper right x coordinate of the solution rectangle. required Returns: Type Description Tuple[app.utils.utils.PT, float] A tuple containing the point and the value of the objective function. Source code in app/models/fastmodel.py def optimize ( near : List [ PT ], far : List [ PT ], xmin : float , xmax : float , ymin : float , ymax : float ) -> Tuple [ PT , float ]: '''FastModel optimize function Args: near: set of points we want to get close to. far: set of points we want to get far from. xmin: lower left `x` coordinate of the solution rectangle. xmax: lower right `x` coordinate of the solution rectangle. ymin: upper left `x` coordinate of the solution rectangle. ymax: upper right `x` coordinate of the solution rectangle. Returns: A tuple containing the point and the value of the objective function. ''' # find optimal x xnear = [ C ( x , w ) for x , _ , w , _ in near ] xfar = [ C ( x , w ) for x , _ , w , _ in far ] xboundaries = [ C ( xmin ), C ( xmax ) ] x , cx = solvecoord ( xnear , xfar , xboundaries ) # find optimal y ynear = [ C ( y , w ) for _ , y , w , _ in near ] yfar = [ C ( y , w ) for _ , y , w , _ in far ] yboundaries = [ C ( ymin ), C ( ymax )] y , cy = solvecoord ( ynear , yfar , yboundaries ) return PT ( x , y , w = 0 , kind = 'FastModel' ), cx + cy","title":"optimize()"},{"location":"api/models/#app.models.fastmodel.precalc_sums","text":"Source code in app/models/fastmodel.py def precalc_sums ( coord : List [ C ]) -> Tuple [ List [ float ], List [ float ]]: n = len ( coord ) sumW = [ 0. ] * n sumWM = [ 0. ] * n for i , ( x , w ) in enumerate ( coord ): if i > 0 : sumW [ i ] = sumW [ i - 1 ] sumWM [ i ] = sumWM [ i - 1 ] sumW [ i ] += w sumWM [ i ] += x * w return sumW , sumWM","title":"precalc_sums()"},{"location":"api/models/#app.models.fastmodel.solvecoord","text":"Source code in app/models/fastmodel.py def solvecoord ( cnear : List [ C ], cfar : List [ C ], boundaries : List [ C ]) -> Tuple [ float , float ]: cnear = sorted ( cnear , key = lambda x : x . c ) cfar = sorted ( cfar , key = lambda x : x . c ) sumw_near , sumwm_near = precalc_sums ( cnear ) sumw_far , sumwm_far = precalc_sums ( cfar ) near_vals = [ c . c for c in cnear ] far_vals = [ c . c for c in cfar ] opt = 1e18 ans = 0 for x , _ in cnear + cfar + boundaries : cost = getcost ( x , near_vals , sumw_near , sumwm_near ) cost -= getcost ( x , far_vals , sumw_far , sumwm_far ) if cost < opt : opt = cost ans = x return ans , opt","title":"solvecoord()"},{"location":"api/models/#app.models.fussymodel","text":"","title":"fussymodel"},{"location":"api/models/#app.models.fussymodel.dot","text":"Source code in app/models/fussymodel.py def dot ( a , b ): return sum ( x * y for x , y in zip ( a , b ))","title":"dot()"},{"location":"api/models/#app.models.fussymodel.evalZ1","text":"Source code in app/models/fussymodel.py def evalZ1 ( near : List [ PT ], X : float , Y : float ): return max ( w * ( abs ( x - X ) + abs ( y - Y )) for x , y , w , _ in near )","title":"evalZ1()"},{"location":"api/models/#app.models.fussymodel.evalZ2","text":"Source code in app/models/fussymodel.py def evalZ2 ( xca , yca , xcb , ycb , X , Y ): return abs ( xca - X ) + abs ( yca - Y ) + abs ( X - xcb ) + abs ( Y - ycb )","title":"evalZ2()"},{"location":"api/models/#app.models.fussymodel.extractconstants","text":"Source code in app/models/fussymodel.py def extractconstants ( arr : List [ PT ]): xs = [ x for x , _ , _ , _ in arr ] ys = [ y for _ , y , _ , _ in arr ] ws = [ w for _ , _ , w , _ in arr ] return xs , ys , ws","title":"extractconstants()"},{"location":"api/models/#app.models.fussymodel.optimize","text":"Source code in app/models/fussymodel.py def optimize ( near : List [ PT ], far : List [ PT ], xmin : float , xmax : float , ymin : float , ymax : float ): xs_near , ys_near , ws_near = extractconstants ( near ) xs_far , ys_far , ws_far = extractconstants ( far ) xca = dot ( xs_near , ws_near ) / len ( near ) yca = dot ( ys_near , ws_near ) / len ( near ) xcb = dot ( xs_far , ws_far ) / len ( far ) ycb = dot ( ys_far , ws_far ) / len ( far ) X1 , Y1 = solveZ1 ( xs_near , ys_near , ws_near , xmin , xmax , ymin , ymax ) X2 , Y2 = solveZ2 ( xca , yca , xcb , ycb , xmin , xmax , ymin , ymax ) U1 = max ( evalZ1 ( near , X1 , Y1 ), evalZ1 ( near , X2 , Y2 )) U2 = max ( evalZ2 ( xca , yca , xcb , ycb , X1 , Y1 ), evalZ2 ( xca , yca , xcb , ycb , X2 , Y2 )) L1 = evalZ1 ( near , X1 , Y1 ) L2 = evalZ2 ( xca , yca , xcb , ycb , X2 , Y2 ) prob = pulp . LpProblem ( 'FussyModel' , pulp . LpMaximize ) # for first model ps = [ pulp . LpVariable ( f 'p_ { i } ' ) for i in range ( len ( near )) ] qs = [ pulp . LpVariable ( f 'q_ { i } ' ) for i in range ( len ( near )) ] # for second model ts = [ pulp . LpVariable ( f 't_ { i } ' , 0 ) for i in range ( 4 ) ] lmb = pulp . LpVariable ( 'lambda' , 0 , 1 ) Z1 = pulp . LpVariable ( 'Z1' , 0 ) Z2 = pulp . LpVariable ( 'Z2' , 0 ) X = pulp . LpVariable ( 'X' , xmin , xmax ) Y = pulp . LpVariable ( 'Y' , ymin , ymax ) # objective function prob += lmb # restrictions prob += U1 * lmb - L1 * lmb <= U1 - Z1 prob += U2 * lmb - L2 * lmb <= U2 - Z2 # from Z1 model for p , q , x , y , w in zip ( ps , qs , xs_near , ys_near , ws_near ): prob += p >= x - X prob += p >= X - x prob += q >= y - Y prob += q >= Y - y prob += w * p + w * q <= Z1 # from Z2 model prob += Z2 == ts [ 0 ] + ts [ 1 ] + ts [ 2 ] + ts [ 3 ] prob += ts [ 0 ] >= X - xca prob += ts [ 0 ] >= xca - X prob += ts [ 1 ] >= Y - yca prob += ts [ 1 ] >= yca - Y prob += ts [ 2 ] >= X - xcb prob += ts [ 2 ] >= xcb - X prob += ts [ 3 ] >= Y - ycb prob += ts [ 3 ] >= ycb - Y prob . solve ( pulp . PULP_CBC_CMD ( msg = False )) assert pulp . LpStatus [ prob . status ] == 'Optimal' return PT ( X . varValue , Y . varValue , w = 0 , kind = 'FussyModel' ), Z1 . varValue + Z2 . varValue","title":"optimize()"},{"location":"api/models/#app.models.fussymodel.solveZ1","text":"Source code in app/models/fussymodel.py def solveZ1 ( xs : List [ float ], ys : List [ float ], ws : List [ float ], xmin : float , xmax : float , ymin : float , ymax : float ): n = len ( xs ) prob = pulp . LpProblem ( 'Z1_objective' ) Z1 = pulp . LpVariable ( 'Z1' , 0 ) X = pulp . LpVariable ( 'X' , xmin , xmax ) Y = pulp . LpVariable ( 'Y' , ymin , ymax ) ps = [ pulp . LpVariable ( f 'p_ { i } ' ) for i in range ( n ) ] qs = [ pulp . LpVariable ( f 'q_ { i } ' ) for i in range ( n ) ] prob += Z1 for p , q , x , y , w in zip ( ps , qs , xs , ys , ws ): prob += p >= x - X prob += p >= X - x prob += q >= y - Y prob += q >= Y - y prob += w * p + w * q <= Z1 prob . solve ( pulp . PULP_CBC_CMD ( msg = False )) assert pulp . LpStatus [ prob . status ] == 'Optimal' return X . varValue , Y . varValue","title":"solveZ1()"},{"location":"api/models/#app.models.fussymodel.solveZ2","text":"Source code in app/models/fussymodel.py def solveZ2 ( xca : float , yca : float , xcb : float , ycb : float , xmin : float , xmax : float , ymin : float , ymax : float ): prob = pulp . LpProblem ( 'Z2_objective' ) Z2 = pulp . LpVariable ( 'Z2' , 0 ) X = pulp . LpVariable ( 'X' , xmin , xmax ) Y = pulp . LpVariable ( 'Y' , ymin , ymax ) ts = [ pulp . LpVariable ( f 't_ { i } ' , 0 ) for i in range ( 4 ) ] prob += Z2 prob += Z2 == ts [ 0 ] + ts [ 1 ] + ts [ 2 ] + ts [ 3 ] prob += ts [ 0 ] >= X - xca prob += ts [ 0 ] >= xca - X prob += ts [ 1 ] >= Y - yca prob += ts [ 1 ] >= yca - Y prob += ts [ 2 ] >= X - xcb prob += ts [ 2 ] >= xcb - X prob += ts [ 3 ] >= Y - ycb prob += ts [ 3 ] >= ycb - Y prob . solve ( pulp . PULP_CBC_CMD ( msg = False )) assert pulp . LpStatus [ prob . status ] == 'Optimal' return X . varValue , Y . varValue","title":"solveZ2()"},{"location":"api/utils/","text":"errors ErrorNotWithinBox ErrorPointFormat ErrorReadingFile ErrorWholeFormat ErrorXYFormat utils floatRE HELP_TEXT init_logger ( logger_name ) Source code in app/utils/utils.py def init_logger ( logger_name ): # create logger logger = logging . getLogger ( logger_name ) logger . setLevel ( logging . DEBUG ) if not logger . handlers : # create console handler and set level to debug ch = logging . FileHandler ( f ' { logger_name } .log' , mode = 'w' ) ch . setLevel ( logging . DEBUG ) # create formatter formatter = logging . Formatter ( ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) # add formatter to ch ch . setFormatter ( formatter ) # add ch to logger logger . addHandler ( ch ) return logger Load An enumeration. fromFile fromSample fromSidebar PARAMS PT PT(x, y, w, kind) SidebarPlaceholderSample SidebarPlaceholderText","title":"utils"},{"location":"api/utils/#app.utils","text":"","title":"app.utils"},{"location":"api/utils/#app.utils.errors","text":"","title":"errors"},{"location":"api/utils/#app.utils.errors.ErrorNotWithinBox","text":"","title":"ErrorNotWithinBox"},{"location":"api/utils/#app.utils.errors.ErrorPointFormat","text":"","title":"ErrorPointFormat"},{"location":"api/utils/#app.utils.errors.ErrorReadingFile","text":"","title":"ErrorReadingFile"},{"location":"api/utils/#app.utils.errors.ErrorWholeFormat","text":"","title":"ErrorWholeFormat"},{"location":"api/utils/#app.utils.errors.ErrorXYFormat","text":"","title":"ErrorXYFormat"},{"location":"api/utils/#app.utils.utils","text":"","title":"utils"},{"location":"api/utils/#app.utils.utils.floatRE","text":"","title":"floatRE"},{"location":"api/utils/#app.utils.utils.HELP_TEXT","text":"","title":"HELP_TEXT"},{"location":"api/utils/#app.utils.utils.init_logger","text":"Source code in app/utils/utils.py def init_logger ( logger_name ): # create logger logger = logging . getLogger ( logger_name ) logger . setLevel ( logging . DEBUG ) if not logger . handlers : # create console handler and set level to debug ch = logging . FileHandler ( f ' { logger_name } .log' , mode = 'w' ) ch . setLevel ( logging . DEBUG ) # create formatter formatter = logging . Formatter ( ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) # add formatter to ch ch . setFormatter ( formatter ) # add ch to logger logger . addHandler ( ch ) return logger","title":"init_logger()"},{"location":"api/utils/#app.utils.utils.Load","text":"An enumeration.","title":"Load"},{"location":"api/utils/#app.utils.utils.Load.fromFile","text":"","title":"fromFile"},{"location":"api/utils/#app.utils.utils.Load.fromSample","text":"","title":"fromSample"},{"location":"api/utils/#app.utils.utils.Load.fromSidebar","text":"","title":"fromSidebar"},{"location":"api/utils/#app.utils.utils.PARAMS","text":"","title":"PARAMS"},{"location":"api/utils/#app.utils.utils.PT","text":"PT(x, y, w, kind)","title":"PT"},{"location":"api/utils/#app.utils.utils.SidebarPlaceholderSample","text":"","title":"SidebarPlaceholderSample"},{"location":"api/utils/#app.utils.utils.SidebarPlaceholderText","text":"","title":"SidebarPlaceholderText"}]}